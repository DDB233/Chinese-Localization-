{"files":[{"pattern":"*.twee","rules":[{"type":"regex","pattern":"/::[^\\n]+/gm","action":"mask"},{"type":"regex","pattern":"/\\{[^\\}]+?\\}/g","action":"mask"},{"type":"function","function":"const result = [];\r\nconst lineSplitter = /(\\r?\\n)/g;\r\nlet lineStart = 0;\r\n\r\n// 按行分割文本并保留换行符位置\r\nconst lines = text.split(lineSplitter);\r\n\r\nfor (let i = 0; i < lines.length; i += 2) {\r\n    const lineContent = lines[i];\r\n    const lineEnd = lineStart + lineContent.length;\r\n    \r\n    // 当前行的标签匹配\r\n    // const tagRegex = /<<[^>]+>>|<[^>]+?>/g;\r\n    const tagRegex = /<<.+?>>|<[^>]+?>|\\[\\[.+?\\]\\]/g;\r\n    let match;\r\n    const excludeInLine = [];\r\n    \r\n    // 逐行匹配标签\r\n    while ((match = tagRegex.exec(lineContent)) !== null) {\r\n        const globalStart = lineStart + match.index;\r\n        const globalEnd = globalStart + match[0].length - 1;\r\n        excludeInLine.push({ start: globalStart, end: globalEnd });\r\n    }\r\n    \r\n    // 计算本行有效区间\r\n    let cursor = lineStart;\r\n    for (const range of excludeInLine) {\r\n        if (range.start > cursor) {\r\n            result.push({\r\n                start: cursor,\r\n                end: range.start\r\n            });\r\n        }\r\n        cursor = Math.max(cursor, range.end + 1);\r\n    }\r\n    \r\n    // 处理行尾内容\r\n    if (cursor <= lineEnd - 1) {\r\n        result.push({\r\n            start: cursor,\r\n            end: lineEnd\r\n        });\r\n    }\r\n    \r\n    // 更新下一行起始位置（包含换行符）\r\n    if (lines[i+1]) {\r\n        lineStart = lineEnd + lines[i+1].length;\r\n    } else {\r\n        lineStart = lineEnd;\r\n    }\r\n}\r\n\r\nreturn result.length ? (result.length > 1 ? result : result[0]) : undefined;"},{"type":"regex","pattern":"/\\[\\[(.+?)\\|.+?\\]\\]/g","captureGroups":"1"}],"options":{"readEncoding":"","writeEncoding":""}}]}